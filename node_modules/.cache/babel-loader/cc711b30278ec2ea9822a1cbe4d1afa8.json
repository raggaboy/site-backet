{"ast":null,"code":"import PropTypes from 'prop-types';\nimport createConnector from \"../core/createConnector.js\";\nimport { getCurrentRefinementValue, hasMultipleIndices, getIndexId } from \"../core/indexUtils.js\";\nimport { shallowEqual, omit } from \"../core/utils.js\";\n/**\n * connectScrollTo connector provides the logic to build a widget that will\n * let the page scroll to a certain point.\n * @name connectScrollTo\n * @kind connector\n * @propType {string} [scrollOn=\"page\"] - Widget searchState key on which to listen for changes, default to the pagination widget.\n * @providedPropType {any} value - the current refinement applied to the widget listened by scrollTo\n * @providedPropType {boolean} hasNotChanged - indicates whether the refinement came from the scrollOn argument (for instance page by default)\n */\n\nexport default createConnector({\n  displayName: 'AlgoliaScrollTo',\n  $$type: 'ais.scrollTo',\n  propTypes: {\n    scrollOn: PropTypes.string\n  },\n  defaultProps: {\n    scrollOn: 'page'\n  },\n  getProvidedProps: function getProvidedProps(props, searchState) {\n    var id = props.scrollOn;\n    var value = getCurrentRefinementValue(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, id, null);\n\n    if (!this._prevSearchState) {\n      this._prevSearchState = {};\n    } // Get the subpart of the state that interest us\n\n\n    if (hasMultipleIndices({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    })) {\n      searchState = searchState.indices ? searchState.indices[getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      })] : {};\n    } // if there is a change in the app that has been triggered by another element\n    // than \"props.scrollOn (id) or the Configure widget, we need to keep track of\n    // the search state to know if there's a change in the app that was not triggered\n    // by the props.scrollOn (id) or the Configure widget. This is useful when\n    // using ScrollTo in combination of Pagination. As pagination can be change\n    // by every widget, we want to scroll only if it cames from the pagination\n    // widget itself. We also remove the configure key from the search state to\n    // do this comparison because for now configure values are not present in the\n    // search state before a first refinement has been made and will false the results.\n    // See: https://github.com/algolia/react-instantsearch/issues/164\n\n\n    var cleanedSearchState = omit(searchState, ['configure', id]);\n    var hasNotChanged = shallowEqual(this._prevSearchState, cleanedSearchState);\n    this._prevSearchState = cleanedSearchState;\n    return {\n      value: value,\n      hasNotChanged: hasNotChanged\n    };\n  }\n});","map":{"version":3,"names":["PropTypes","createConnector","getCurrentRefinementValue","hasMultipleIndices","getIndexId","shallowEqual","omit","displayName","$$type","propTypes","scrollOn","string","defaultProps","getProvidedProps","props","searchState","id","value","ais","contextValue","multiIndexContext","indexContextValue","_prevSearchState","indices","cleanedSearchState","hasNotChanged"],"sources":["/home/dedm/Documents/sript/lab3-script/node_modules/react-instantsearch-core/dist/es/connectors/connectScrollTo.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport createConnector from \"../core/createConnector.js\";\nimport { getCurrentRefinementValue, hasMultipleIndices, getIndexId } from \"../core/indexUtils.js\";\nimport { shallowEqual, omit } from \"../core/utils.js\";\n/**\n * connectScrollTo connector provides the logic to build a widget that will\n * let the page scroll to a certain point.\n * @name connectScrollTo\n * @kind connector\n * @propType {string} [scrollOn=\"page\"] - Widget searchState key on which to listen for changes, default to the pagination widget.\n * @providedPropType {any} value - the current refinement applied to the widget listened by scrollTo\n * @providedPropType {boolean} hasNotChanged - indicates whether the refinement came from the scrollOn argument (for instance page by default)\n */\n\nexport default createConnector({\n  displayName: 'AlgoliaScrollTo',\n  $$type: 'ais.scrollTo',\n  propTypes: {\n    scrollOn: PropTypes.string\n  },\n  defaultProps: {\n    scrollOn: 'page'\n  },\n  getProvidedProps: function getProvidedProps(props, searchState) {\n    var id = props.scrollOn;\n    var value = getCurrentRefinementValue(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }, id, null);\n\n    if (!this._prevSearchState) {\n      this._prevSearchState = {};\n    } // Get the subpart of the state that interest us\n\n\n    if (hasMultipleIndices({\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    })) {\n      searchState = searchState.indices ? searchState.indices[getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      })] : {};\n    } // if there is a change in the app that has been triggered by another element\n    // than \"props.scrollOn (id) or the Configure widget, we need to keep track of\n    // the search state to know if there's a change in the app that was not triggered\n    // by the props.scrollOn (id) or the Configure widget. This is useful when\n    // using ScrollTo in combination of Pagination. As pagination can be change\n    // by every widget, we want to scroll only if it cames from the pagination\n    // widget itself. We also remove the configure key from the search state to\n    // do this comparison because for now configure values are not present in the\n    // search state before a first refinement has been made and will false the results.\n    // See: https://github.com/algolia/react-instantsearch/issues/164\n\n\n    var cleanedSearchState = omit(searchState, ['configure', id]);\n    var hasNotChanged = shallowEqual(this._prevSearchState, cleanedSearchState);\n    this._prevSearchState = cleanedSearchState;\n    return {\n      value: value,\n      hasNotChanged: hasNotChanged\n    };\n  }\n});"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,YAAtB;AACA,OAAOC,eAAP,MAA4B,4BAA5B;AACA,SAASC,yBAAT,EAAoCC,kBAApC,EAAwDC,UAAxD,QAA0E,uBAA1E;AACA,SAASC,YAAT,EAAuBC,IAAvB,QAAmC,kBAAnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeL,eAAe,CAAC;EAC7BM,WAAW,EAAE,iBADgB;EAE7BC,MAAM,EAAE,cAFqB;EAG7BC,SAAS,EAAE;IACTC,QAAQ,EAAEV,SAAS,CAACW;EADX,CAHkB;EAM7BC,YAAY,EAAE;IACZF,QAAQ,EAAE;EADE,CANe;EAS7BG,gBAAgB,EAAE,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,WAAjC,EAA8C;IAC9D,IAAIC,EAAE,GAAGF,KAAK,CAACJ,QAAf;IACA,IAAIO,KAAK,GAAGf,yBAAyB,CAACY,KAAD,EAAQC,WAAR,EAAqB;MACxDG,GAAG,EAAEJ,KAAK,CAACK,YAD6C;MAExDC,iBAAiB,EAAEN,KAAK,CAACO;IAF+B,CAArB,EAGlCL,EAHkC,EAG9B,IAH8B,CAArC;;IAKA,IAAI,CAAC,KAAKM,gBAAV,EAA4B;MAC1B,KAAKA,gBAAL,GAAwB,EAAxB;IACD,CAT6D,CAS5D;;;IAGF,IAAInB,kBAAkB,CAAC;MACrBe,GAAG,EAAEJ,KAAK,CAACK,YADU;MAErBC,iBAAiB,EAAEN,KAAK,CAACO;IAFJ,CAAD,CAAtB,EAGI;MACFN,WAAW,GAAGA,WAAW,CAACQ,OAAZ,GAAsBR,WAAW,CAACQ,OAAZ,CAAoBnB,UAAU,CAAC;QACjEc,GAAG,EAAEJ,KAAK,CAACK,YADsD;QAEjEC,iBAAiB,EAAEN,KAAK,CAACO;MAFwC,CAAD,CAA9B,CAAtB,GAGR,EAHN;IAID,CApB6D,CAoB5D;IACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IAGA,IAAIG,kBAAkB,GAAGlB,IAAI,CAACS,WAAD,EAAc,CAAC,WAAD,EAAcC,EAAd,CAAd,CAA7B;IACA,IAAIS,aAAa,GAAGpB,YAAY,CAAC,KAAKiB,gBAAN,EAAwBE,kBAAxB,CAAhC;IACA,KAAKF,gBAAL,GAAwBE,kBAAxB;IACA,OAAO;MACLP,KAAK,EAAEA,KADF;MAELQ,aAAa,EAAEA;IAFV,CAAP;EAID;AAhD4B,CAAD,CAA9B"},"metadata":{},"sourceType":"module"}