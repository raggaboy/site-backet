{"ast":null,"code":"'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n\n  return value;\n}\n\nfunction isObjectOrArrayOrFunction(value) {\n  return typeof value === 'function' || Array.isArray(value) || Object.prototype.toString.call(value) === '[object Object]';\n}\n\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n\n  for (var key in source) {\n    if (!Object.prototype.hasOwnProperty.call(source, key) || key === '__proto__') {\n      continue;\n    }\n\n    var sourceVal = source[key];\n    var targetVal = target[key];\n\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      continue;\n    }\n\n    if (isObjectOrArrayOrFunction(targetVal) && isObjectOrArrayOrFunction(sourceVal)) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n\n  return target;\n}\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\n\n\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = merge;","map":{"version":3,"names":["clone","value","_merge","Array","isArray","isObjectOrArrayOrFunction","Object","prototype","toString","call","target","source","key","hasOwnProperty","sourceVal","targetVal","merge","i","l","arguments","length","module","exports"],"sources":["/home/dedm/Documents/sript/lab3-script/node_modules/algoliasearch-helper/src/functions/merge.js"],"sourcesContent":["'use strict';\n\nfunction clone(value) {\n  if (typeof value === 'object' && value !== null) {\n    return _merge(Array.isArray(value) ? [] : {}, value);\n  }\n  return value;\n}\n\nfunction isObjectOrArrayOrFunction(value) {\n  return (\n    typeof value === 'function' ||\n    Array.isArray(value) ||\n    Object.prototype.toString.call(value) === '[object Object]'\n  );\n}\n\nfunction _merge(target, source) {\n  if (target === source) {\n    return target;\n  }\n\n  for (var key in source) {\n    if (\n      !Object.prototype.hasOwnProperty.call(source, key) ||\n      key === '__proto__'\n    ) {\n      continue;\n    }\n\n    var sourceVal = source[key];\n    var targetVal = target[key];\n\n    if (typeof targetVal !== 'undefined' && typeof sourceVal === 'undefined') {\n      continue;\n    }\n\n    if (\n      isObjectOrArrayOrFunction(targetVal) &&\n      isObjectOrArrayOrFunction(sourceVal)\n    ) {\n      target[key] = _merge(targetVal, sourceVal);\n    } else {\n      target[key] = clone(sourceVal);\n    }\n  }\n  return target;\n}\n\n/**\n * This method is like Object.assign, but recursively merges own and inherited\n * enumerable keyed properties of source objects into the destination object.\n *\n * NOTE: this behaves like lodash/merge, but:\n * - does mutate functions if they are a source\n * - treats non-plain objects as plain\n * - does not work for circular objects\n * - treats sparse arrays as sparse\n * - does not convert Array-like objects (Arguments, NodeLists, etc.) to arrays\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n */\n\nfunction merge(target) {\n  if (!isObjectOrArrayOrFunction(target)) {\n    target = {};\n  }\n\n  for (var i = 1, l = arguments.length; i < l; i++) {\n    var source = arguments[i];\n\n    if (isObjectOrArrayOrFunction(source)) {\n      _merge(target, source);\n    }\n  }\n  return target;\n}\n\nmodule.exports = merge;\n"],"mappings":"AAAA;;AAEA,SAASA,KAAT,CAAeC,KAAf,EAAsB;EACpB,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;IAC/C,OAAOC,MAAM,CAACC,KAAK,CAACC,OAAN,CAAcH,KAAd,IAAuB,EAAvB,GAA4B,EAA7B,EAAiCA,KAAjC,CAAb;EACD;;EACD,OAAOA,KAAP;AACD;;AAED,SAASI,yBAAT,CAAmCJ,KAAnC,EAA0C;EACxC,OACE,OAAOA,KAAP,KAAiB,UAAjB,IACAE,KAAK,CAACC,OAAN,CAAcH,KAAd,CADA,IAEAK,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BR,KAA/B,MAA0C,iBAH5C;AAKD;;AAED,SAASC,MAAT,CAAgBQ,MAAhB,EAAwBC,MAAxB,EAAgC;EAC9B,IAAID,MAAM,KAAKC,MAAf,EAAuB;IACrB,OAAOD,MAAP;EACD;;EAED,KAAK,IAAIE,GAAT,IAAgBD,MAAhB,EAAwB;IACtB,IACE,CAACL,MAAM,CAACC,SAAP,CAAiBM,cAAjB,CAAgCJ,IAAhC,CAAqCE,MAArC,EAA6CC,GAA7C,CAAD,IACAA,GAAG,KAAK,WAFV,EAGE;MACA;IACD;;IAED,IAAIE,SAAS,GAAGH,MAAM,CAACC,GAAD,CAAtB;IACA,IAAIG,SAAS,GAAGL,MAAM,CAACE,GAAD,CAAtB;;IAEA,IAAI,OAAOG,SAAP,KAAqB,WAArB,IAAoC,OAAOD,SAAP,KAAqB,WAA7D,EAA0E;MACxE;IACD;;IAED,IACET,yBAAyB,CAACU,SAAD,CAAzB,IACAV,yBAAyB,CAACS,SAAD,CAF3B,EAGE;MACAJ,MAAM,CAACE,GAAD,CAAN,GAAcV,MAAM,CAACa,SAAD,EAAYD,SAAZ,CAApB;IACD,CALD,MAKO;MACLJ,MAAM,CAACE,GAAD,CAAN,GAAcZ,KAAK,CAACc,SAAD,CAAnB;IACD;EACF;;EACD,OAAOJ,MAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASM,KAAT,CAAeN,MAAf,EAAuB;EACrB,IAAI,CAACL,yBAAyB,CAACK,MAAD,CAA9B,EAAwC;IACtCA,MAAM,GAAG,EAAT;EACD;;EAED,KAAK,IAAIO,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCH,CAAC,GAAGC,CAA1C,EAA6CD,CAAC,EAA9C,EAAkD;IAChD,IAAIN,MAAM,GAAGQ,SAAS,CAACF,CAAD,CAAtB;;IAEA,IAAIZ,yBAAyB,CAACM,MAAD,CAA7B,EAAuC;MACrCT,MAAM,CAACQ,MAAD,EAASC,MAAT,CAAN;IACD;EACF;;EACD,OAAOD,MAAP;AACD;;AAEDW,MAAM,CAACC,OAAP,GAAiBN,KAAjB"},"metadata":{},"sourceType":"script"}