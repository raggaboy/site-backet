{"ast":null,"code":"'use strict';\n\nmodule.exports = generateTrees;\n\nvar orderBy = require('../functions/orderBy');\n\nvar find = require('../functions/find');\n\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\n\nvar fv = require('../functions/escapeFacetValue');\n\nvar escapeFacetValue = fv.escapeFacetValue;\nvar unescapeFacetValue = fv.unescapeFacetValue;\n\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement = state.hierarchicalFacetsRefinements[hierarchicalFacet.name] && state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0] || '';\n\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(hierarchicalFacet);\n\n    var hierarchicalRootPath = state._getHierarchicalRootPath(hierarchicalFacet);\n\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(hierarchicalFacet);\n\n    var sortBy = prepareHierarchicalFacetSortBy(state._getHierarchicalFacetSortBy(hierarchicalFacet));\n    var rootExhaustive = hierarchicalFacetResult.every(function (facetResult) {\n      return facetResult.exhaustive;\n    });\n    var generateTreeFn = generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, hierarchicalFacetRefinement);\n    var results = hierarchicalFacetResult;\n\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(hierarchicalRootPath.split(hierarchicalSeparator).length);\n    }\n\n    return results.reduce(generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null,\n      // root level, no count\n      isRefined: true,\n      // root level, always refined\n      path: null,\n      // root level, no path\n      escapedValue: null,\n      exhaustive: rootExhaustive,\n      data: null\n    });\n  };\n}\n\nfunction generateHierarchicalTree(sortBy, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel, currentRefinement) {\n  return function generateTree(hierarchicalTree, hierarchicalFacetResult, currentHierarchicalLevel) {\n    var parent = hierarchicalTree;\n\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n      parent = hierarchicalTree;\n\n      while (level < currentHierarchicalLevel) {\n        /**\n         * @type {object[]]} hierarchical data\n         */\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\n        parent = find(data, function (subtree) {\n          return subtree.isRefined;\n        });\n        level++;\n      }\n    } // we found a refined parent, let's add current level data under it\n\n\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n      var picked = Object.keys(hierarchicalFacetResult.data).map(function (facetValue) {\n        return [facetValue, hierarchicalFacetResult.data[facetValue]];\n      }).filter(function (tuple) {\n        var facetValue = tuple[0];\n        return onlyMatchingTree(facetValue, parent.path || hierarchicalRootPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel);\n      });\n      parent.data = orderBy(picked.map(function (tuple) {\n        var facetValue = tuple[0];\n        var facetCount = tuple[1];\n        return format(facetCount, facetValue, hierarchicalSeparator, unescapeFacetValue(currentRefinement), hierarchicalFacetResult.exhaustive);\n      }), sortBy[0], sortBy[1]);\n    }\n\n    return hierarchicalTree;\n  };\n}\n\nfunction onlyMatchingTree(facetValue, parentPath, currentRefinement, hierarchicalSeparator, hierarchicalRootPath, hierarchicalShowParentLevel) {\n  // we want the facetValue is a child of hierarchicalRootPath\n  if (hierarchicalRootPath && (facetValue.indexOf(hierarchicalRootPath) !== 0 || hierarchicalRootPath === facetValue)) {\n    return false;\n  } // we always want root levels (only when there is no prefix path)\n\n\n  return !hierarchicalRootPath && facetValue.indexOf(hierarchicalSeparator) === -1 || // if there is a rootPath, being root level mean 1 level under rootPath\n  hierarchicalRootPath && facetValue.split(hierarchicalSeparator).length - hierarchicalRootPath.split(hierarchicalSeparator).length === 1 || // if current refinement is a root level and current facetValue is a root level,\n  // keep the facetValue\n  facetValue.indexOf(hierarchicalSeparator) === -1 && currentRefinement.indexOf(hierarchicalSeparator) === -1 || // currentRefinement is a child of the facet value\n  currentRefinement.indexOf(facetValue) === 0 || // facetValue is a child of the current parent, add it\n  facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 && (hierarchicalShowParentLevel || facetValue.indexOf(currentRefinement) === 0);\n}\n\nfunction format(facetCount, facetValue, hierarchicalSeparator, currentRefinement, exhaustive) {\n  var parts = facetValue.split(hierarchicalSeparator);\n  return {\n    name: parts[parts.length - 1].trim(),\n    path: facetValue,\n    escapedValue: escapeFacetValue(facetValue),\n    count: facetCount,\n    isRefined: currentRefinement === facetValue || currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n    exhaustive: exhaustive,\n    data: null\n  };\n}","map":{"version":3,"names":["module","exports","generateTrees","orderBy","require","find","prepareHierarchicalFacetSortBy","fv","escapeFacetValue","unescapeFacetValue","state","generate","hierarchicalFacetResult","hierarchicalFacetIndex","hierarchicalFacet","hierarchicalFacets","hierarchicalFacetRefinement","hierarchicalFacetsRefinements","name","hierarchicalSeparator","_getHierarchicalFacetSeparator","hierarchicalRootPath","_getHierarchicalRootPath","hierarchicalShowParentLevel","_getHierarchicalShowParentLevel","sortBy","_getHierarchicalFacetSortBy","rootExhaustive","every","facetResult","exhaustive","generateTreeFn","generateHierarchicalTree","results","slice","split","length","reduce","count","isRefined","path","escapedValue","data","currentRefinement","generateTree","hierarchicalTree","currentHierarchicalLevel","parent","level","Array","isArray","subtree","picked","Object","keys","map","facetValue","filter","tuple","onlyMatchingTree","facetCount","format","parentPath","indexOf","parts","trim"],"sources":["/home/dedm/Documents/sript/lab3-script/node_modules/algoliasearch-helper/src/SearchResults/generate-hierarchical-tree.js"],"sourcesContent":["'use strict';\n\nmodule.exports = generateTrees;\n\nvar orderBy = require('../functions/orderBy');\nvar find = require('../functions/find');\nvar prepareHierarchicalFacetSortBy = require('../functions/formatSort');\nvar fv = require('../functions/escapeFacetValue');\nvar escapeFacetValue = fv.escapeFacetValue;\nvar unescapeFacetValue = fv.unescapeFacetValue;\n\nfunction generateTrees(state) {\n  return function generate(hierarchicalFacetResult, hierarchicalFacetIndex) {\n    var hierarchicalFacet = state.hierarchicalFacets[hierarchicalFacetIndex];\n    var hierarchicalFacetRefinement =\n      (state.hierarchicalFacetsRefinements[hierarchicalFacet.name] &&\n        state.hierarchicalFacetsRefinements[hierarchicalFacet.name][0]) ||\n      '';\n    var hierarchicalSeparator = state._getHierarchicalFacetSeparator(\n      hierarchicalFacet\n    );\n    var hierarchicalRootPath = state._getHierarchicalRootPath(\n      hierarchicalFacet\n    );\n    var hierarchicalShowParentLevel = state._getHierarchicalShowParentLevel(\n      hierarchicalFacet\n    );\n    var sortBy = prepareHierarchicalFacetSortBy(\n      state._getHierarchicalFacetSortBy(hierarchicalFacet)\n    );\n\n    var rootExhaustive = hierarchicalFacetResult.every(function(facetResult) {\n      return facetResult.exhaustive;\n    });\n\n    var generateTreeFn = generateHierarchicalTree(\n      sortBy,\n      hierarchicalSeparator,\n      hierarchicalRootPath,\n      hierarchicalShowParentLevel,\n      hierarchicalFacetRefinement\n    );\n\n    var results = hierarchicalFacetResult;\n\n    if (hierarchicalRootPath) {\n      results = hierarchicalFacetResult.slice(\n        hierarchicalRootPath.split(hierarchicalSeparator).length\n      );\n    }\n\n    return results.reduce(generateTreeFn, {\n      name: state.hierarchicalFacets[hierarchicalFacetIndex].name,\n      count: null, // root level, no count\n      isRefined: true, // root level, always refined\n      path: null, // root level, no path\n      escapedValue: null,\n      exhaustive: rootExhaustive,\n      data: null\n    });\n  };\n}\n\nfunction generateHierarchicalTree(\n  sortBy,\n  hierarchicalSeparator,\n  hierarchicalRootPath,\n  hierarchicalShowParentLevel,\n  currentRefinement\n) {\n  return function generateTree(\n    hierarchicalTree,\n    hierarchicalFacetResult,\n    currentHierarchicalLevel\n  ) {\n    var parent = hierarchicalTree;\n\n    if (currentHierarchicalLevel > 0) {\n      var level = 0;\n\n      parent = hierarchicalTree;\n\n      while (level < currentHierarchicalLevel) {\n        /**\n         * @type {object[]]} hierarchical data\n         */\n        var data = parent && Array.isArray(parent.data) ? parent.data : [];\n        parent = find(data, function(subtree) {\n          return subtree.isRefined;\n        });\n        level++;\n      }\n    }\n\n    // we found a refined parent, let's add current level data under it\n    if (parent) {\n      // filter values in case an object has multiple categories:\n      //   {\n      //     categories: {\n      //       level0: ['beers', 'bières'],\n      //       level1: ['beers > IPA', 'bières > Belges']\n      //     }\n      //   }\n      //\n      // If parent refinement is `beers`, then we do not want to have `bières > Belges`\n      // showing up\n\n      var picked = Object.keys(hierarchicalFacetResult.data)\n        .map(function(facetValue) {\n          return [facetValue, hierarchicalFacetResult.data[facetValue]];\n        })\n        .filter(function(tuple) {\n          var facetValue = tuple[0];\n          return onlyMatchingTree(\n            facetValue,\n            parent.path || hierarchicalRootPath,\n            currentRefinement,\n            hierarchicalSeparator,\n            hierarchicalRootPath,\n            hierarchicalShowParentLevel\n          );\n        });\n\n      parent.data = orderBy(\n        picked.map(function(tuple) {\n          var facetValue = tuple[0];\n          var facetCount = tuple[1];\n\n          return format(\n            facetCount,\n            facetValue,\n            hierarchicalSeparator,\n            unescapeFacetValue(currentRefinement),\n            hierarchicalFacetResult.exhaustive\n          );\n        }),\n        sortBy[0],\n        sortBy[1]\n      );\n    }\n\n    return hierarchicalTree;\n  };\n}\n\nfunction onlyMatchingTree(\n  facetValue,\n  parentPath,\n  currentRefinement,\n  hierarchicalSeparator,\n  hierarchicalRootPath,\n  hierarchicalShowParentLevel\n) {\n  // we want the facetValue is a child of hierarchicalRootPath\n  if (\n    hierarchicalRootPath &&\n    (facetValue.indexOf(hierarchicalRootPath) !== 0 ||\n      hierarchicalRootPath === facetValue)\n  ) {\n    return false;\n  }\n\n  // we always want root levels (only when there is no prefix path)\n  return (\n    (!hierarchicalRootPath &&\n      facetValue.indexOf(hierarchicalSeparator) === -1) ||\n    // if there is a rootPath, being root level mean 1 level under rootPath\n    (hierarchicalRootPath &&\n      facetValue.split(hierarchicalSeparator).length -\n        hierarchicalRootPath.split(hierarchicalSeparator).length ===\n        1) ||\n    // if current refinement is a root level and current facetValue is a root level,\n    // keep the facetValue\n    (facetValue.indexOf(hierarchicalSeparator) === -1 &&\n      currentRefinement.indexOf(hierarchicalSeparator) === -1) ||\n    // currentRefinement is a child of the facet value\n    currentRefinement.indexOf(facetValue) === 0 ||\n    // facetValue is a child of the current parent, add it\n    (facetValue.indexOf(parentPath + hierarchicalSeparator) === 0 &&\n      (hierarchicalShowParentLevel ||\n        facetValue.indexOf(currentRefinement) === 0))\n  );\n}\n\nfunction format(\n  facetCount,\n  facetValue,\n  hierarchicalSeparator,\n  currentRefinement,\n  exhaustive\n) {\n  var parts = facetValue.split(hierarchicalSeparator);\n  return {\n    name: parts[parts.length - 1].trim(),\n    path: facetValue,\n    escapedValue: escapeFacetValue(facetValue),\n    count: facetCount,\n    isRefined:\n      currentRefinement === facetValue ||\n      currentRefinement.indexOf(facetValue + hierarchicalSeparator) === 0,\n    exhaustive: exhaustive,\n    data: null\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}