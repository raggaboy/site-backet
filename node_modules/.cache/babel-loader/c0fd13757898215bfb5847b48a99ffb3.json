{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport PropTypes from 'prop-types';\nimport createConnector from \"../core/createConnector.js\";\nimport { cleanUpValue, getIndexId, refineValue, getCurrentRefinementValue, getResults } from \"../core/indexUtils.js\";\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attribute` prop must be present in “attributes for faceting”\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * The values inside the attribute must be JavaScript numbers (not strings).\n * @propType {string} attribute - Name of the attribute for faceting\n * @propType {{min?: number, max?: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=0] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {number} min - the minimum value available.\n * @providedPropType {number} max - the maximum value available.\n * @providedPropType {number} precision - Number of digits after decimal point to use.\n */\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nvar namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  var pow = Math.pow(10, precision);\n  var min;\n\n  if (typeof boundaries.min === 'number' && isFinite(boundaries.min)) {\n    min = boundaries.min;\n  } else if (typeof stats.min === 'number' && isFinite(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  var max;\n\n  if (typeof boundaries.max === 'number' && isFinite(boundaries.max)) {\n    max = boundaries.max;\n  } else if (typeof stats.max === 'number' && isFinite(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  var _getCurrentRefinement = getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), {}),\n      min = _getCurrentRefinement.min,\n      max = _getCurrentRefinement.max;\n\n  var isFloatPrecision = Boolean(props.precision);\n  var nextMin = min;\n\n  if (typeof nextMin === 'string') {\n    nextMin = isFloatPrecision ? parseFloat(nextMin) : parseInt(nextMin, 10);\n  }\n\n  var nextMax = max;\n\n  if (typeof nextMax === 'string') {\n    nextMax = isFloatPrecision ? parseFloat(nextMax) : parseInt(nextMax, 10);\n  }\n\n  var refinement = {\n    min: nextMin,\n    max: nextMax\n  };\n  var hasMinBound = props.min !== undefined;\n  var hasMaxBound = props.max !== undefined;\n  var hasMinRefinment = refinement.min !== undefined;\n  var hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction getCurrentRefinementWithRange(refinement, range) {\n  return {\n    min: refinement.min !== undefined ? refinement.min : range.min,\n    max: refinement.max !== undefined ? refinement.max : range.max\n  };\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  var next;\n\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction _refine(props, searchState, nextRefinement, currentRange, context) {\n  var nextMin = nextRefinement.min,\n      nextMax = nextRefinement.max;\n  var currentMinRange = currentRange.min,\n      currentMaxRange = currentRange.max;\n  var isMinReset = nextMin === undefined || nextMin === '';\n  var isMaxReset = nextMax === undefined || nextMax === '';\n  var nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  var nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n  var isNextMinValid = isMinReset || isFinite(nextMinAsNumber);\n  var isNextMaxValid = isMaxReset || isFinite(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  var id = getId(props);\n  var resetPage = true;\n\n  var nextValue = _defineProperty({}, id, {\n    min: nextValueForRefinement(props.min !== undefined, isMinReset, currentMinRange, nextMinAsNumber),\n    max: nextValueForRefinement(props.max !== undefined, isMaxReset, currentMaxRange, nextMaxAsNumber)\n  });\n\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaRange',\n  $$type: 'ais.range',\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    defaultRefinement: PropTypes.shape({\n      min: PropTypes.number,\n      max: PropTypes.number\n    }),\n    min: PropTypes.number,\n    max: PropTypes.number,\n    precision: PropTypes.number,\n    header: PropTypes.node,\n    footer: PropTypes.node\n  },\n  defaultProps: {\n    precision: 0\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attribute = props.attribute,\n        precision = props.precision,\n        minBound = props.min,\n        maxBound = props.max;\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var hasFacet = results && results.getFacetByName(attribute);\n    var stats = hasFacet ? results.getFacetStats(attribute) || {} : {};\n    var facetValues = hasFacet ? results.getFacetValues(attribute) : [];\n    var count = facetValues.map(function (v) {\n      return {\n        value: v.name,\n        count: v.count\n      };\n    });\n\n    var _getCurrentRange = getCurrentRange({\n      min: minBound,\n      max: maxBound\n    }, stats, precision),\n        rangeMin = _getCurrentRange.min,\n        rangeMax = _getCurrentRange.max; // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behavior change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n\n\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax\n    };\n    var currentRefinement = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: getCurrentRefinementWithRange(currentRefinement, this._currentRange),\n      count: count,\n      precision: precision\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(params, props, searchState) {\n    var attribute = props.attribute;\n\n    var _getCurrentRefinement2 = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }),\n        min = _getCurrentRefinement2.min,\n        max = _getCurrentRefinement2.max;\n\n    params = params.addDisjunctiveFacet(attribute);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attribute, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attribute, '<=', max);\n    }\n\n    return params;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var _this = this;\n\n    var _this$_currentRange = this._currentRange,\n        minRange = _this$_currentRange.min,\n        maxRange = _this$_currentRange.max;\n\n    var _getCurrentRefinement3 = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }),\n        minValue = _getCurrentRefinement3.min,\n        maxValue = _getCurrentRefinement3.max;\n\n    var items = [];\n    var hasMin = minValue !== undefined;\n    var hasMax = maxValue !== undefined;\n    var shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    var shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      var fragments = [hasMin ? \"\".concat(minValue, \" <= \") : '', props.attribute, hasMax ? \" <= \".concat(maxValue) : ''];\n      items.push({\n        label: fragments.join(''),\n        attribute: props.attribute,\n        value: function value(nextState) {\n          return _refine(props, nextState, {}, _this._currentRange, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue\n          });\n        },\n        currentRefinement: getCurrentRefinementWithRange({\n          min: minValue,\n          max: maxValue\n        }, {\n          min: minRange,\n          max: maxRange\n        })\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }),\n      items: items\n    };\n  }\n});","map":{"version":3,"names":["_defineProperty","PropTypes","createConnector","cleanUpValue","getIndexId","refineValue","getCurrentRefinementValue","getResults","getId","props","attribute","namespace","getCurrentRange","boundaries","stats","precision","pow","Math","min","isFinite","undefined","max","floor","ceil","getCurrentRefinement","searchState","currentRange","context","_getCurrentRefinement","concat","isFloatPrecision","Boolean","nextMin","parseFloat","parseInt","nextMax","refinement","hasMinBound","hasMaxBound","hasMinRefinment","hasMaxRefinment","Error","getCurrentRefinementWithRange","range","nextValueForRefinement","hasBound","isReset","value","next","_refine","nextRefinement","currentMinRange","currentMaxRange","isMinReset","isMaxReset","nextMinAsNumber","nextMaxAsNumber","isNextMinValid","isNextMaxValid","id","resetPage","nextValue","_cleanUp","displayName","$$type","propTypes","string","isRequired","defaultRefinement","shape","number","header","node","footer","defaultProps","getProvidedProps","searchResults","minBound","maxBound","results","ais","contextValue","multiIndexContext","indexContextValue","hasFacet","getFacetByName","getFacetStats","facetValues","getFacetValues","count","map","v","name","_getCurrentRange","rangeMin","rangeMax","_currentRange","currentRefinement","canRefine","length","refine","cleanUp","getSearchParameters","params","_getCurrentRefinement2","addDisjunctiveFacet","addNumericRefinement","getMetadata","_this","_this$_currentRange","minRange","maxRange","_getCurrentRefinement3","minValue","maxValue","items","hasMin","hasMax","shouldDisplayMinLabel","shouldDisplayMaxLabel","fragments","push","label","join","nextState","index"],"sources":["/home/dedm/Documents/sript/lab3-script/node_modules/react-instantsearch-core/dist/es/connectors/connectRange.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport PropTypes from 'prop-types';\nimport createConnector from \"../core/createConnector.js\";\nimport { cleanUpValue, getIndexId, refineValue, getCurrentRefinementValue, getResults } from \"../core/indexUtils.js\";\n/**\n * connectRange connector provides the logic to create connected\n * components that will give the ability for a user to refine results using\n * a numeric range.\n * @name connectRange\n * @kind connector\n * @requirements The attribute passed to the `attribute` prop must be present in “attributes for faceting”\n * on the Algolia dashboard or configured as `attributesForFaceting` via a set settings call to the Algolia API.\n * The values inside the attribute must be JavaScript numbers (not strings).\n * @propType {string} attribute - Name of the attribute for faceting\n * @propType {{min?: number, max?: number}} [defaultRefinement] - Default searchState of the widget containing the start and the end of the range.\n * @propType {number} [min] - Minimum value. When this isn't set, the minimum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [max] - Maximum value. When this isn't set, the maximum value will be automatically computed by Algolia using the data in the index.\n * @propType {number} [precision=0] - Number of digits after decimal point to use.\n * @providedPropType {function} refine - a function to select a range.\n * @providedPropType {function} createURL - a function to generate a URL for the corresponding search state\n * @providedPropType {string} currentRefinement - the refinement currently applied\n * @providedPropType {number} min - the minimum value available.\n * @providedPropType {number} max - the maximum value available.\n * @providedPropType {number} precision - Number of digits after decimal point to use.\n */\n\nfunction getId(props) {\n  return props.attribute;\n}\n\nvar namespace = 'range';\n\nfunction getCurrentRange(boundaries, stats, precision) {\n  var pow = Math.pow(10, precision);\n  var min;\n\n  if (typeof boundaries.min === 'number' && isFinite(boundaries.min)) {\n    min = boundaries.min;\n  } else if (typeof stats.min === 'number' && isFinite(stats.min)) {\n    min = stats.min;\n  } else {\n    min = undefined;\n  }\n\n  var max;\n\n  if (typeof boundaries.max === 'number' && isFinite(boundaries.max)) {\n    max = boundaries.max;\n  } else if (typeof stats.max === 'number' && isFinite(stats.max)) {\n    max = stats.max;\n  } else {\n    max = undefined;\n  }\n\n  return {\n    min: min !== undefined ? Math.floor(min * pow) / pow : min,\n    max: max !== undefined ? Math.ceil(max * pow) / pow : max\n  };\n}\n\nfunction getCurrentRefinement(props, searchState, currentRange, context) {\n  var _getCurrentRefinement = getCurrentRefinementValue(props, searchState, context, \"\".concat(namespace, \".\").concat(getId(props)), {}),\n      min = _getCurrentRefinement.min,\n      max = _getCurrentRefinement.max;\n\n  var isFloatPrecision = Boolean(props.precision);\n  var nextMin = min;\n\n  if (typeof nextMin === 'string') {\n    nextMin = isFloatPrecision ? parseFloat(nextMin) : parseInt(nextMin, 10);\n  }\n\n  var nextMax = max;\n\n  if (typeof nextMax === 'string') {\n    nextMax = isFloatPrecision ? parseFloat(nextMax) : parseInt(nextMax, 10);\n  }\n\n  var refinement = {\n    min: nextMin,\n    max: nextMax\n  };\n  var hasMinBound = props.min !== undefined;\n  var hasMaxBound = props.max !== undefined;\n  var hasMinRefinment = refinement.min !== undefined;\n  var hasMaxRefinment = refinement.max !== undefined;\n\n  if (hasMinBound && hasMinRefinment && refinement.min < currentRange.min) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (hasMaxBound && hasMaxRefinment && refinement.max > currentRange.max) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  if (hasMinBound && !hasMinRefinment) {\n    refinement.min = currentRange.min;\n  }\n\n  if (hasMaxBound && !hasMaxRefinment) {\n    refinement.max = currentRange.max;\n  }\n\n  return refinement;\n}\n\nfunction getCurrentRefinementWithRange(refinement, range) {\n  return {\n    min: refinement.min !== undefined ? refinement.min : range.min,\n    max: refinement.max !== undefined ? refinement.max : range.max\n  };\n}\n\nfunction nextValueForRefinement(hasBound, isReset, range, value) {\n  var next;\n\n  if (!hasBound && range === value) {\n    next = undefined;\n  } else if (hasBound && isReset) {\n    next = range;\n  } else {\n    next = value;\n  }\n\n  return next;\n}\n\nfunction _refine(props, searchState, nextRefinement, currentRange, context) {\n  var nextMin = nextRefinement.min,\n      nextMax = nextRefinement.max;\n  var currentMinRange = currentRange.min,\n      currentMaxRange = currentRange.max;\n  var isMinReset = nextMin === undefined || nextMin === '';\n  var isMaxReset = nextMax === undefined || nextMax === '';\n  var nextMinAsNumber = !isMinReset ? parseFloat(nextMin) : undefined;\n  var nextMaxAsNumber = !isMaxReset ? parseFloat(nextMax) : undefined;\n  var isNextMinValid = isMinReset || isFinite(nextMinAsNumber);\n  var isNextMaxValid = isMaxReset || isFinite(nextMaxAsNumber);\n\n  if (!isNextMinValid || !isNextMaxValid) {\n    throw Error(\"You can't provide non finite values to the range connector.\");\n  }\n\n  if (nextMinAsNumber < currentMinRange) {\n    throw Error(\"You can't provide min value lower than range.\");\n  }\n\n  if (nextMaxAsNumber > currentMaxRange) {\n    throw Error(\"You can't provide max value greater than range.\");\n  }\n\n  var id = getId(props);\n  var resetPage = true;\n\n  var nextValue = _defineProperty({}, id, {\n    min: nextValueForRefinement(props.min !== undefined, isMinReset, currentMinRange, nextMinAsNumber),\n    max: nextValueForRefinement(props.max !== undefined, isMaxReset, currentMaxRange, nextMaxAsNumber)\n  });\n\n  return refineValue(searchState, nextValue, context, resetPage, namespace);\n}\n\nfunction _cleanUp(props, searchState, context) {\n  return cleanUpValue(searchState, context, \"\".concat(namespace, \".\").concat(getId(props)));\n}\n\nexport default createConnector({\n  displayName: 'AlgoliaRange',\n  $$type: 'ais.range',\n  propTypes: {\n    id: PropTypes.string,\n    attribute: PropTypes.string.isRequired,\n    defaultRefinement: PropTypes.shape({\n      min: PropTypes.number,\n      max: PropTypes.number\n    }),\n    min: PropTypes.number,\n    max: PropTypes.number,\n    precision: PropTypes.number,\n    header: PropTypes.node,\n    footer: PropTypes.node\n  },\n  defaultProps: {\n    precision: 0\n  },\n  getProvidedProps: function getProvidedProps(props, searchState, searchResults) {\n    var attribute = props.attribute,\n        precision = props.precision,\n        minBound = props.min,\n        maxBound = props.max;\n    var results = getResults(searchResults, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    var hasFacet = results && results.getFacetByName(attribute);\n    var stats = hasFacet ? results.getFacetStats(attribute) || {} : {};\n    var facetValues = hasFacet ? results.getFacetValues(attribute) : [];\n    var count = facetValues.map(function (v) {\n      return {\n        value: v.name,\n        count: v.count\n      };\n    });\n\n    var _getCurrentRange = getCurrentRange({\n      min: minBound,\n      max: maxBound\n    }, stats, precision),\n        rangeMin = _getCurrentRange.min,\n        rangeMax = _getCurrentRange.max; // The searchState is not always in sync with the helper state. For example\n    // when we set boundaries on the first render the searchState don't have\n    // the correct refinement. If this behavior change in the upcoming version\n    // we could store the range inside the searchState instead of rely on `this`.\n\n\n    this._currentRange = {\n      min: rangeMin,\n      max: rangeMax\n    };\n    var currentRefinement = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n    return {\n      min: rangeMin,\n      max: rangeMax,\n      canRefine: count.length > 0,\n      currentRefinement: getCurrentRefinementWithRange(currentRefinement, this._currentRange),\n      count: count,\n      precision: precision\n    };\n  },\n  refine: function refine(props, searchState, nextRefinement) {\n    return _refine(props, searchState, nextRefinement, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  cleanUp: function cleanUp(props, searchState) {\n    return _cleanUp(props, searchState, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    });\n  },\n  getSearchParameters: function getSearchParameters(params, props, searchState) {\n    var attribute = props.attribute;\n\n    var _getCurrentRefinement2 = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }),\n        min = _getCurrentRefinement2.min,\n        max = _getCurrentRefinement2.max;\n\n    params = params.addDisjunctiveFacet(attribute);\n\n    if (min !== undefined) {\n      params = params.addNumericRefinement(attribute, '>=', min);\n    }\n\n    if (max !== undefined) {\n      params = params.addNumericRefinement(attribute, '<=', max);\n    }\n\n    return params;\n  },\n  getMetadata: function getMetadata(props, searchState) {\n    var _this = this;\n\n    var _this$_currentRange = this._currentRange,\n        minRange = _this$_currentRange.min,\n        maxRange = _this$_currentRange.max;\n\n    var _getCurrentRefinement3 = getCurrentRefinement(props, searchState, this._currentRange, {\n      ais: props.contextValue,\n      multiIndexContext: props.indexContextValue\n    }),\n        minValue = _getCurrentRefinement3.min,\n        maxValue = _getCurrentRefinement3.max;\n\n    var items = [];\n    var hasMin = minValue !== undefined;\n    var hasMax = maxValue !== undefined;\n    var shouldDisplayMinLabel = hasMin && minValue !== minRange;\n    var shouldDisplayMaxLabel = hasMax && maxValue !== maxRange;\n\n    if (shouldDisplayMinLabel || shouldDisplayMaxLabel) {\n      var fragments = [hasMin ? \"\".concat(minValue, \" <= \") : '', props.attribute, hasMax ? \" <= \".concat(maxValue) : ''];\n      items.push({\n        label: fragments.join(''),\n        attribute: props.attribute,\n        value: function value(nextState) {\n          return _refine(props, nextState, {}, _this._currentRange, {\n            ais: props.contextValue,\n            multiIndexContext: props.indexContextValue\n          });\n        },\n        currentRefinement: getCurrentRefinementWithRange({\n          min: minValue,\n          max: maxValue\n        }, {\n          min: minRange,\n          max: maxRange\n        })\n      });\n    }\n\n    return {\n      id: getId(props),\n      index: getIndexId({\n        ais: props.contextValue,\n        multiIndexContext: props.indexContextValue\n      }),\n      items: items\n    };\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}