{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _excluded = [\"resultsFacetValues\"],\n    _excluded2 = [\"resultsFacetValues\"],\n    _excluded3 = [\"resultsFacetValues\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from \"./createWidgetsManager.js\";\nimport createStore from \"./createStore.js\";\nimport { HIGHLIGHT_TAGS } from \"./highlight.js\";\nimport { hasMultipleIndices } from \"./indexUtils.js\";\nimport { version as ReactVersion } from 'react';\nimport version from \"./version.js\";\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\n\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\n\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n}; // Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\n\n\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\n\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\n\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  var isFirstWidgetIndex = isIndexWidget(firstWidget);\n  var isSecondWidgetIndex = isIndexWidget(secondWidget);\n\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n\n  return 0;\n}; // This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\n\n\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\n\n\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n      _ref$initialState = _ref.initialState,\n      initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n      searchClient = _ref.searchClient,\n      resultsState = _ref.resultsState,\n      stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var searchCounter;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread(_objectSpread({}, indices), {}, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n          mainParameters = _getSearchParameters.mainParameters,\n          derivedParameters = _getSearchParameters.derivedParameters;\n\n      searchCounter = derivedParameters.length + 1; // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n            parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      searchCounter--;\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {}; // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results = _objectSpread(_objectSpread({}, results), {}, _defineProperty({}, indexId, event.results));\n      } else {\n        results = event.results;\n      }\n\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      var resultsFacetValues = currentState.resultsFacetValues,\n          partialState = _objectWithoutProperties(currentState, _excluded);\n\n      store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: searchCounter > 0,\n        error: null\n      }));\n    };\n  }\n\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, _excluded2);\n\n    store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n            resultsFacetValues = _store$getState.resultsFacetValues,\n            partialState = _objectWithoutProperties(_store$getState, _excluded3);\n\n        store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    } // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n\n    if ((!client.transporter || client._cacheHydrated) && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    } // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n\n\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n      var baseMethod = client.search;\n\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread(_objectSpread({}, request), {}, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(function (acc, result) {\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  } // Called whenever a widget has been rendered with new props.\n\n\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      metadata: metadata,\n      searching: true\n    })); // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n        query = _ref5.query,\n        _ref5$maxFacetHits = _ref5.maxFacetHits,\n        maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits; // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread7;\n\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread(_objectSpread({}, store.getState().resultsFacetValues), {}, (_objectSpread7 = {}, _defineProperty(_objectSpread7, facetName, content.facetHits), _defineProperty(_objectSpread7, \"query\", query), _objectSpread7))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex); // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}\n\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  } // add a value noop, which gets replaced once the widgets are mounted\n\n\n  return resultsState.metadata.map(function (datum) {\n    return _objectSpread(_objectSpread({\n      value: function value() {\n        return {};\n      }\n    }, datum), {}, {\n      items: datum.items && datum.items.map(function (item) {\n        return _objectSpread(_objectSpread({\n          value: function value() {\n            return {};\n          }\n        }, item), {}, {\n          items: item.items && item.items.map(function (nestedItem) {\n            return _objectSpread({\n              value: function value() {\n                return {};\n              }\n            }, nestedItem);\n          })\n        });\n      })\n    });\n  });\n}","map":{"version":3,"names":["_objectWithoutProperties","_defineProperty","_excluded","_excluded2","_excluded3","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","algoliasearchHelper","createWidgetsManager","createStore","HIGHLIGHT_TAGS","hasMultipleIndices","version","ReactVersion","addAlgoliaAgents","searchClient","addAlgoliaAgent","concat","isMultiIndexContext","widget","ais","props","contextValue","multiIndexContext","indexContextValue","isTargetedIndexEqualIndex","indexId","targetedIndex","isIndexWidget","Boolean","isIndexWidgetEqualIndex","sortIndexWidgetsFirst","firstWidget","secondWidget","isFirstWidgetIndex","isSecondWidgetIndex","serializeQueryParameters","parameters","isObjectOrArray","value","prototype","toString","call","encode","format","_len","args","Array","_key","replace","encodeURIComponent","map","JSON","stringify","join","createInstantSearchManager","_ref","indexName","_ref$initialState","initialState","resultsState","stalledSearchDelay","helper","on","handleNewSearch","handleSearchSuccess","handleSearchError","skip","stalledSearchTimer","initialSearchParameters","state","searchCounter","widgetsManager","onWidgetsUpdate","hydrateSearchClient","store","widgets","metadata","hydrateMetadata","results","hydrateResultsState","error","searching","isSearchStalled","searchingForFacetValues","skipSearch","updateClient","client","setClient","search","clearCache","getMetadata","getWidgets","getSearchParameters","sharedParameters","reduce","res","mainParameters","targetedIndexEqualMainIndex","subIndexEqualMainIndex","sort","derivedIndices","targetedIndexNotEqualMainIndex","subIndexNotEqualMainIndex","indices","derivedParameters","_getSearchParameters","derivedHelpers","slice","derivedHelper","detach","_ref2","derive","setState","_ref3","event","getState","isDerivedHelpersEmpty","getFacetByName","currentState","nextIsSearchStalled","hasPendingRequests","clearTimeout","resultsFacetValues","partialState","_ref4","setTimeout","_store$getState","transporter","_cacheHydrated","_useCache","baseMethod","requests","_len2","methodArgs","_key2","requestsWithSerializedParams","request","params","responsesCache","get","method","isArray","hydrateSearchClientWithMultiIndexRequest","hydrateSearchClientWithSingleIndexRequest","set","acc","result","rawResults","index","cache","_internalIndexId","SearchResults","SearchParameters","transitionState","nextSearchState","searchState","onExternalStateUpdate","onSearchForFacetValues","_ref5","facetName","query","_ref5$maxFacetHits","maxFacetHits","maxFacetHitsWithinRange","Math","max","min","searchForFacetValues","then","content","_objectSpread7","facetHits","catch","updateIndex","newIndex","setIndex","getWidgetsIds","meta","id","datum","items","item","nestedItem"],"sources":["/home/dedm/Documents/sript/lab3-script/node_modules/react-instantsearch-core/dist/es/core/createInstantSearchManager.js"],"sourcesContent":["import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _excluded = [\"resultsFacetValues\"],\n    _excluded2 = [\"resultsFacetValues\"],\n    _excluded3 = [\"resultsFacetValues\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from \"./createWidgetsManager.js\";\nimport createStore from \"./createStore.js\";\nimport { HIGHLIGHT_TAGS } from \"./highlight.js\";\nimport { hasMultipleIndices } from \"./indexUtils.js\";\nimport { version as ReactVersion } from 'react';\nimport version from \"./version.js\";\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\n\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\n\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n}; // Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\n\n\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\n\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\n\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  var isFirstWidgetIndex = isIndexWidget(firstWidget);\n  var isSecondWidgetIndex = isIndexWidget(secondWidget);\n\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n\n  return 0;\n}; // This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\n\n\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\n\n\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n      _ref$initialState = _ref.initialState,\n      initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n      searchClient = _ref.searchClient,\n      resultsState = _ref.resultsState,\n      stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var searchCounter;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread(_objectSpread({}, indices), {}, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n          mainParameters = _getSearchParameters.mainParameters,\n          derivedParameters = _getSearchParameters.derivedParameters;\n\n      searchCounter = derivedParameters.length + 1; // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n            parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      searchCounter--;\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {}; // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results = _objectSpread(_objectSpread({}, results), {}, _defineProperty({}, indexId, event.results));\n      } else {\n        results = event.results;\n      }\n\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      var resultsFacetValues = currentState.resultsFacetValues,\n          partialState = _objectWithoutProperties(currentState, _excluded);\n\n      store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: searchCounter > 0,\n        error: null\n      }));\n    };\n  }\n\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, _excluded2);\n\n    store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n            resultsFacetValues = _store$getState.resultsFacetValues,\n            partialState = _objectWithoutProperties(_store$getState, _excluded3);\n\n        store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    } // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n\n    if ((!client.transporter || client._cacheHydrated) && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    } // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n\n\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n      var baseMethod = client.search;\n\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread(_objectSpread({}, request), {}, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(function (acc, result) {\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  } // Called whenever a widget has been rendered with new props.\n\n\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      metadata: metadata,\n      searching: true\n    })); // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n        query = _ref5.query,\n        _ref5$maxFacetHits = _ref5.maxFacetHits,\n        maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits;\n    // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread7;\n\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread(_objectSpread({}, store.getState().resultsFacetValues), {}, (_objectSpread7 = {}, _defineProperty(_objectSpread7, facetName, content.facetHits), _defineProperty(_objectSpread7, \"query\", query), _objectSpread7))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex); // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}\n\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  } // add a value noop, which gets replaced once the widgets are mounted\n\n\n  return resultsState.metadata.map(function (datum) {\n    return _objectSpread(_objectSpread({\n      value: function value() {\n        return {};\n      }\n    }, datum), {}, {\n      items: datum.items && datum.items.map(function (item) {\n        return _objectSpread(_objectSpread({\n          value: function value() {\n            return {};\n          }\n        }, item), {}, {\n          items: item.items && item.items.map(function (nestedItem) {\n            return _objectSpread({\n              value: function value() {\n                return {};\n              }\n            }, nestedItem);\n          })\n        });\n      })\n    });\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}